# Exercise 8

## Overview

### **Context**

Hardcoded test data can make our tests predictable but unrealistic. When dealing with complex components, using randomized data helps us uncover hidden bugs and better simulate real-world scenarios. In this exercise, we’ll be using `FakerJS` to replace our static test data with dynamic, more lifelike data, making both our testing and development process more efficient.

### **Learning Outcome**

By the end of this exercise, you will be comfortable using `FakerJS` to create randomized, but still reproducible test data. You’ll understand how to seed FakerJS for consistent test results and know when to use randomized data to identify edge cases in your components. You’ll also see how FakerJS can help us speed up development by providing realistic data to test and build with.

### **Motivation**

Predictable, hardcoded data in tests can mask issues that only appear under specific conditions. By learning to use `FakerJS` for data seeding, we can improve the robustness of our tests, making them more reflective of real-world user interactions. Additionally, having quick access to realistic data makes it easier to develop and verify our components during the build process. This skill is crucial for maintaining high-quality code as your application grows.

### **Problem Statement**

You will continue working on our `DockingSchedule` component that currently relies on hardcoded data for testing. Your challenge is to replace this with randomized data generated by `FakerJS`, while ensuring the tests remain reliable and reproducible by setting a seed value.

### **Key Takeaways**

- **Recognizing Limitations of Hardcoded Data**: Understand how static test data can hide potential issues and why using randomized data is more effective.
- **Using FakerJS for Realistic Test Data**: Learn to use FakerJS to generate a variety of realistic data types, improving the test coverage and quality.
- **Ensuring Test Consistency**: Discover how to set a seed in FakerJS, making sure our tests produce consistent results even with randomized data.

## Tasks

The basic gist is we'll replace the hardcoded data with data generated by FakerJS. Then we'll set a seed so that the data is reproducible.

Here's a broken down list of tasks:

### 1. Create a `generateNotification` function that generates a notification object with a random message.

<details>
  <summary>Hint: Using faker.lorem.sentence()</summary>

```javascript
const generateNotification = () => ({
  id: faker.string.uuid(),
  message: faker.lorem.sentence(),
  timestamp: faker.date.recent().toISOString(),
});
```

This function generates a notification with a random ID, message, and timestamp.

</details>

### 2. Update the GET `/notifications` handler to use the `generateNotification` function.

<details>
  <summary>Hint: Updating the notifications handler</summary>

```javascript
const notificationHandlers = [
  http.get(`${API_BASE}/notifications`, () => {
    const generatedNotifications = Array.from(
      { length: 5 },
      generateNotification
    );
    return HttpResponse.json(generatedNotifications);
  }),
];
```

This handler generates 5 random notifications using the `generateNotification` function.

</details>

### 3. Create a `generateSpacecraft` function that generates a spacecraft object with a random name.

<details>
  <summary>Hint: Using faker.helpers.arrayElement</summary>

```javascript
const generateSpacecraft = () => ({
  id: faker.string.uuid(),
  name: faker.helpers.arrayElement([
    'Voyager',
    'Discovery',
    'Enterprise',
    'Falcon',
    'Orion',
  ]),
  type: faker.helpers.arrayElement([
    'Shuttle',
    'Probe',
    'Station',
    'Lander',
  ]),
  captain: faker.person.fullName(),
});
```

This function generates a spacecraft with a random ID, name (from a predefined list), type, and captain name.

</details>

### 4. Update the GET `/spacecrafts` handler to use the `generateSpacecraft` function.

<details>
  <summary>Hint: Updating the spacecrafts handler</summary>

```javascript
http.get(`${API_BASE}/spacecrafts`, () => {
  const generatedSpacecraft = Array.from({ length: 5 }, generateSpacecraft);
  return HttpResponse.json(generatedSpacecraft);
}),
```

This handler generates 5 random spacecraft using the `generateSpacecraft` function.

</details>

### 5. Create a `generateDocking` function that generates a docking object with a random spacecraft ID.

<details>
  <summary>Hint: Linking docking to a spacecraft</summary>

```javascript
const generateDocking = (spacecraftId) => ({
  id: faker.string.uuid(),
  spacecraftId,
  dockingTime: faker.date.soon().toISOString(),
  bayId: faker.number.int({ min: 1, max: 10 }),
  status: faker.helpers.arrayElement([
    'scheduled',
    'docked',
    'departing',
  ]),
});
```

This function generates a docking with a random ID, the provided spacecraft ID, and random values for other properties.

</details>

### 6. Update the rest of the handlers to use the new functions.

<details>
  <summary>Hint: Updating other handlers</summary>

```javascript
// In the POST /dockings handler
const newDocking = generateDocking(foundSpacecraft.id);
dockings.push(newDocking);
return HttpResponse.json(newDocking, { status: 201 });
```

Update other handlers similarly to use the new generate functions where appropriate.

</details>

<details>
  <summary>Hint: Keeping data consistent between API calls</summary>

```javascript
// Initialize data arrays before the handlers
let spacecraft: Spacecraft[] = [];
let dockings: Docking[] = [];
let notifications: Notification[] = [];

// ...handlers
```

This ensures that the data is the same between API calls and we can create and edit data in the handlers.

</details>

### 7. Set a seed value in FakerJS.

<details>
  <summary>Hint: Setting a seed value</summary>

```javascript
// At the top of the file, after importing faker
faker.seed(123); // You can use any number as the seed
```

This will ensure that the data is reproducible. It will always generate the same data when the seed is the same, which can be very useful for testing!

</details>
